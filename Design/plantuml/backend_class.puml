@startuml backend

skinparam linetype ortho

package git {
  interface History {
   BranchForBenchmark getBranch(branch: String, benchmark: Benchmark)
  }

  interface RepositoryHandler {
    BranchForBenchmark fetchGitHistory(branch: String)
  }

  class Commit {
    parents: List<Commit> ' TODO: decide about that
    sha: String
    message: String
    date: java.util.Date
    benchmarkResultsByDevice: Map<Device, BenchmarkResult>
    String getCommitMessage()
    String getSha()
    BenchmarkResult getBenchmarkResult(device: Device)
    Commit getPreviousCommit()
  }
  
  
  class BranchForBenchmark {
    name: String
    benchmark: Benchmark
    commits: List<Commit>
    Commit getCommit(sha: String)
    List<Commit> toList()
  }
    
  interface BenchmarkResult {
    Commit getCommit()
    Benchmark getBenchmark()
    Device getDevice()
    double getSummaryValue()
  }

  class Benchmark {
    # TODO add fields for other info
    name: String
  }

  class Device {
    # TODO add fields for other info
    name: String
  }

  class EmptyBenchmarkResult
  EmptyBenchmarkResult --|> BenchmarkResult
  
  History --> BranchForBenchmark
  History --> RepositoryHandler
  
  BranchForBenchmark o-- Commit
  Commit "1" -- "*" BenchmarkResult
}


package rest {
  class GitApiHandler
  class SpringRestHandler
  
  interface RestHandler {
    void handlePost(json: String)
    void handleGetHistory(json: String)
    void handleGetBenchmarkResult(json: String)
  }
   
  SpringRestHandler --|> RestHandler
}

package database {
  class PostgreSQLHandler
  
  interface DatabaseHandler {
    void updateCommits(commits: List<Commit>)
    void updateBenchmarkResults(results: List<BenchmarkResult>)
    BranchForBenchmark fetchBranch(branch: String, benchmark: Benchmark)
    BenchmarkResult fetchSingleBenchmarkResult(commit: Commit, device: Device, benchmark: Benchmark)
  }
  
  class HistoryDatabase

  class MissingBranchException
  class MissingBenchmarkResultException
  
  DatabaseHandler <- HistoryDatabase
  DatabaseHandler <|-- PostgreSQLHandler
  DatabaseHandler --> MissingBranchException
  DatabaseHandler --> MissingBenchmarkResultException

  class BenchmarkResultDatabase
  
  DatabaseHandler <- BenchmarkResultDatabase
  
  class LazyBenchmarkResult {
    component: BenchmarkResult
  }

  DatabaseHandler <-- LazyBenchmarkResult
}

package benchmark {
  abstract class MatrixBenchmarkResult {
    datapoints: List<MatrixDatapoint>
  }

  abstract class MatrixDatapoint {
    filename: String
    rows: int
    columns: int
    nonzeros: int
  }

  class BlasDatapoint {
    n: int
    r: int
    m: int
    k: int
    operations: List<Operation>
  }

  class Operation {
    name: String
    time: double
    flops: double
    bandwidth: double
    completed: bool
  }

  class ConversionDatapoint {
    conversions: List<Conversion>
  }

  class Conversion {
    name: String
    time: double
    completed: bool
  }

  class SpmvDatapoint {
    formats: List<Format>
    optimal: Format
  }

  class Format {
    name: String
    storage: int
    time: double
    maxRelativeNorm2: double
    completed: bool
  }

  class PreconditionerDatapoint {
    preconditioners: List<Preconditioner>
  }

  class Preconditioner {
    name: String
    generateComponents: List<Component>
    generateTime: double
    applyComponents: List<Component>
    applyTime: double
    completed: bool
  }

  class SolverDatapoint {
    solvers: List<Solver>
  }

  class Solver {
    name: String
    recurrentResiduals: [double]
    trueResiduals: [double]
    implicitResiduals: [double]
    iterationTimestamps: [double]
    rhsNorm: [double]
    residualNorm: [double]
    completed: bool
    generateComponents: List<Component>
    generateTotalTime: double
    applyComponents: List<Component>
    applyTotalTime: double
    applyIterations: int
  }

  class Component {
    name: String
    runtime: double
  }

  interface BenchmarkResultStorage {
    void storeBenchmarkResults(results: List<BenchmarkResult>)
  }

  class SolverBenchmarkResult {
  }

  class SpmvBenchmarkResult {
  }

  class ConversionBenchmarkResult {
  }

  class PreconditionerBenchmarkResult {
  }

  class BlasBenchmarkResult {
    datapoints: List<BlasDatapoint>
  }

  MatrixBenchmarkResult <|-- SolverBenchmarkResult
  MatrixBenchmarkResult <|--- SpmvBenchmarkResult
  MatrixBenchmarkResult <|---- ConversionBenchmarkResult
  MatrixBenchmarkResult <|----- PreconditionerBenchmarkResult

  MatrixDatapoint <|-- SolverDatapoint
  MatrixDatapoint <|--- SpmvDatapoint
  MatrixDatapoint <|---- ConversionDatapoint
  MatrixDatapoint <|----- PreconditionerDatapoint

  MatrixBenchmarkResult -> MatrixDatapoint
  BlasBenchmarkResult -> BlasDatapoint
  PreconditionerBenchmarkResult -> PreconditionerDatapoint
  SpmvBenchmarkResult -> SpmvDatapoint
  SolverBenchmarkResult -> SolverDatapoint
  ConversionBenchmarkResult -> ConversionDatapoint

  BlasDatapoint -> Operation
  PreconditionerDatapoint -> Preconditioner
  SpmvDatapoint -> Format
  SolverDatapoint -> Solver
  ConversionDatapoint -> Conversion

  Solver --> Component
  Component --> Preconditioner
}

package processing {
  class DataProcessor {
    void storeBenchmarkResults(results: List<BenchmarkResult>)
    JSON transformBenchmarkResults(results: List<BenchmarkResult, plotType: PlotType)
  }
  BenchmarkResultStorage <- DataProcessor

  DataProcessor -> SolverSinglePlotTransform
  DataProcessor -> SpmvSinglePlotTransform
  DataProcessor -> ConversionSinglePlotTransform
  DataProcessor -> PreconditionerSinglePlotTransform
  DataProcessor -> BlasSinglePlotTransform
  
  DataProcessor --> SolverMultiPlotTransform
  DataProcessor --> SpmvMultiPlotTransform
  DataProcessor --> ConversionMultiPlotTransform
  DataProcessor --> PreconditionerMultiPlotTransform
  DataProcessor --> BlasMultiPlotTransform

  interface SolverSinglePlotTransform {
    JSON transform(benchmarkResult: SolverBenchmarkResult)
  }

  interface SolverMultiPlotTransform {
    JSON transform(benchmarkResults: List<SolverBenchmarkResult>)
  }


  interface SpmvSinglePlotTransform {
    JSON transform(benchmarkResult: SpmvBenchmarkResult)
  }

  interface SpmvMultiPlotTransform {
    JSON transform(benchmarkResults: List<SpmvBenchmarkResult>)
  }

interface ConversionSinglePlotTransform {
    JSON transform(benchmarkResult: ConversionBenchmarkResult)
  }

  interface ConversionMultiPlotTransform {
    JSON transform(benchmarkResults: List<ConversionBenchmarkResult>)
  }


  interface PreconditionerSinglePlotTransform {
    JSON transform(benchmarkResult: PreconditionerBenchmarkResult)
  }

  interface PreconditionerMultiPlotTransform {
    JSON transform(benchmarkResults: List<PreconditionerBenchmarkResult>)
  }


  interface BlasSinglePlotTransform {
    JSON transform(benchmarkResult: BlasBenchmarkResult)
  }

  interface BlasMultiPlotTransform {
    JSON transform(benchmarkResults: List<BlasBenchmarkResult>)
  }

  class PlotType {
    name: String
  }
}

History <- RestHandler
History <|- HistoryDatabase
BenchmarkResultStorage <|- BenchmarkResultDatabase
RepositoryHandler <|- GitApiHandler
DatabaseHandler -> Commit
DatabaseHandler -> BenchmarkResult
HistoryDatabase -> BranchForBenchmark
BenchmarkResult <|- LazyBenchmarkResult
BenchmarkResult <|-- MatrixBenchmarkResult
BenchmarkResult <|---- BlasBenchmarkResult
BenchmarkResult <- LazyBenchmarkResult
BenchmarkResult <- DataProcessor
DataProcessor <- RestHandler

DatabaseHandler -> Device
DatabaseHandler -> Benchmark

SolverSinglePlotTransform --> SolverBenchmarkResult

SolverMultiPlotTransform --> SolverBenchmarkResult


SpmvSinglePlotTransform --> SpmvBenchmarkResult

SpmvMultiPlotTransform --> SpmvBenchmarkResult


ConversionSinglePlotTransform --> ConversionBenchmarkResult

ConversionMultiPlotTransform --> ConversionBenchmarkResult


PreconditionerSinglePlotTransform --> PreconditionerBenchmarkResult

PreconditionerMultiPlotTransform --> PreconditionerBenchmarkResult


BlasSinglePlotTransform --> BlasBenchmarkResult

BlasMultiPlotTransform --> BlasBenchmarkResult

@enduml
